library ieee; 
use ieee.std_logic_1164.all;

entity CARRY_GENERATOR_GEN is
    generic(
        NBIT_IN : integer; -- Number of bits of input
        NCARRY : integer; -- Number of carries generated by this block
        NBIT_CARRY : integer -- Number of bits for a carry
    );
    port (
        A : in std_logic_vector(NBIT_IN-1 downto 0);
        B : in std_logic_vector(NBIT_IN-1 downto 0);
        C_in : in std_logic;
        O : out std_logic_vector(NCARRY-1 downto 0)
    ) ;
end entity ;

architecture STRUCTURAL of CARRY_GENERATOR_GEN is

    --------------------------------------------------
    -- Function declarations
    --------------------------------------------------

    -- 2's logarithm
    function log2(input:integer) return integer is
        variable temp, log :integer;
    begin
        temp:=input;
        log:=0;
        while (temp /= 0) loop
            temp:=temp/2;
            log:=log+1;
        end loop;
        return log-1;
    end function log2;

    -- 2's power
    function po2(input:integer) return integer is
    variable temp: integer := 1;
    begin 
        for I in 1 to input loop
            temp := temp*2;
        end loop;
        return temp;
    end function po2;

    --------------------------------------------------
    -- Component declarations
    --------------------------------------------------

    component PG
        port (
            A : in std_logic_vector(1 downto 0);
            B : in std_logic_vector(1 downto 0);
            O : out std_logic_vector(1 downto 0)
        );
    end component;

    component G
        port (
            A : in std_logic_vector(1 downto 0);
            B : in std_logic;
            O : out std_logic
        );
    end component;

    component PG_GENERATOR
        port (
            A : in std_logic;
            B : in std_logic;
            O : out std_logic_vector(1 downto 0)
        );
    end component;

    --------------------------------------------------
    -- Type declarations
    --------------------------------------------------

    subtype pg_bus is std_logic_vector(1 downto 0);
    type lower_matrix is array(log2(NBIT_CARRY) downto 0, NBIT_IN-1 downto 0) of pg_bus;
    type upper_matrix is array(log2(NCARRY) downto 0, NCARRY-1 downto 0) of pg_bus;

    --------------------------------------------------
    -- Signal declarations
    --------------------------------------------------

    signal lower_network : lower_matrix;
    signal upper_network : upper_matrix;
    signal CARRY_PG : pg_bus;


begin

    --------------------------------------------------
    -- PG network
    --------------------------------------------------

    PG_NETWORK_GEN : for I in 1 to NBIT_IN-1 generate
        PG_GENERATOR_I : PG_GENERATOR 
        port map(A(I), B(I), lower_network(0, I));
    end generate;

    PG_GENERATOR_CARRY : PG_GENERATOR
    port map (
        A => A(0),
        B => B(0),
        O => CARRY_PG
    );


    G_CARRY : G
    port map (
        A => CARRY_PG,
        B => C_in,
        O => lower_network(0,0)(0)
    );


    --------------------------------------------------
    -- Lower network
    --------------------------------------------------

    LOOP1 : for I in 1 to log2(NBIT_CARRY) generate
        LOOP2 : for J in 1 to NBIT_IN generate
            -- Build one block every 2^I, the first is a G, the others are all PG
            IF1 : if((J mod po2(I))=0) generate
                IF_LOWER_G : if(J=po2(I)) generate
                    -- First of the line, build a G block
                    GEN_LOWER_G : G 
                    port map(lower_network(I-1, J-1), lower_network(I-1, J-po2(I-1)-1)(0), lower_network(I, J-1)(0));
                end generate;

                IF_LOWER_PG : if(J/=po2(I)) generate
                    -- Not the first of the line, build a PG block
                    GEN_LOWER_PG : PG
                    port map(lower_network(I-1, J-1), lower_network(I-1, J-po2(I-1)-1), lower_network(I, J-1));
                end generate;
            end generate;
        end generate;
    end generate;

    -- Wire upper network to lower network
    WIRE_LOOP: for J in 1 to NCARRY generate
        upper_network(0, J-1) <= lower_network(log2(NBIT_CARRY), J*NBIT_CARRY-1);
    end generate;


    --------------------------------------------------
    -- Upper network
    --------------------------------------------------

    LOOP3 : for I in 1 to log2(NCARRY) generate
        -- For each window
        LOOP4 : for X in 1 to NCARRY/po2(I) generate
            -- For each element of the window
            LOOP5 : for Y in 1 to po2(I) generate
                -- If in the upper half of the window, fill with blocks
                IF_UPPER_BLOCK : if(Y>po2(I-1)) generate
                    -- Create a block
                    IF_UPPER_G : if(X=1) generate
                        -- First window of the line, build a G block
                        GEN_UPPER_G : G 
                        port map(upper_network(I-1, (X-1)*po2(I)+Y-1), upper_network(I-1, X*po2(I)-po2(I-1)-1)(0), upper_network(I, (X-1)*po2(I)+Y-1)(0));
                    end generate;

                    IF_UPPER_PG : if(X/=1) generate
                        -- Not the first window of the line, build a PG block
                        GEN_UPPER_PG : PG 
                        port map(upper_network(I-1, (X-1)*po2(I)+Y-1), upper_network(I-1, X*po2(I)-po2(I-1)-1), upper_network(I, (X-1)*po2(I)+Y-1));
                    end generate;
                end generate;

                IF_UPPER_WIRE : if(Y<=po2(I-1)) generate
                    -- Wire down to the next line
                    upper_network(I, (X-1)*po2(I)+Y-1) <= upper_network(I-1, (X-1)*po2(I)+Y-1);
                end generate;
            end generate;
        end generate;
    end generate;

    -- Link upper network to output
    LOOP6 : for J in 1 to NCARRY generate
        O(J-1) <= upper_network(log2(NCARRY), J-1)(0);
    end generate;
end architecture;

